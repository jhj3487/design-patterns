---
title: "🎯 Design Pattern 01 – 전략 패턴 (Strategy Pattern)"
date: 2025-10-16
categories: [Design Pattern, OOP]
tags: [Strategy Pattern, 객체지향, Java, Design Patterns]
description: 변화에 유연하게 대응하기 위해 상속보다 구성을 사용하고, 전략 패턴으로 행동을 캡슐화/교체하는 방법을 정리합니다.
---


## 📘 개요

**전략 패턴(Strategy Pattern)** 은 *알고리즘군*을 정의하고 각 알고리즘을 캡슐화하여 **상호 교체 가능**하게 만들며, 알고리즘을 **그것을 사용하는 클라이언트로부터 독립적으로** 변화시킬 수 있게 한다.

> 💬 프로그램에서 진리는 **변화**다.  
> 변화에 유연하게 대응하기 위해 **상속보다 구성(Composition)** 을 사용한다.

---

## 🧩 1️⃣ 상속의 한계

- 재사용성은 좋지만 **유연성 부족**  
- 부모 클래스 변경 시 **모든 자식 클래스 영향**  
- **코드 중복** 및 **불필요한 상속**  
- **변화가 잦은 영역**에는 부적합 → 유지보수 어려움  

> “상속은 코드를 공유하지만, 변화에는 닫혀 있다.”

---

## 🧩 2️⃣ 인터페이스(구현)의 한계

- 새로운 기능 추가 시 **모든 클래스에 구현 필요**  
- 인터페이스 변경 시 **모든 구현 클래스 수정 필요**  
- **코드 중복**, **재사용 어려움**

> “인터페이스는 유연하지만, 구현의 반복을 초래한다.”

---

## 🧩 3️⃣ 문제 해결 방향

- **변하지 않는 것**과 **변하는 것**을 분리한다.  
- 변하는 부분은 **별도의 클래스로 묶어 캡슐화(Encapsulation)** 한다.  
- 즉, **“구성을 통해 행동을 바꾼다.”**

> 👉 변화하는 코드를 따로 분리하면, 새로운 행동 추가 시 기존 클래스 수정이 필요 없다.  
> (OCP – 개방-폐쇄 원칙 충족)

---

## 🧩 3️⃣-1️⃣ 구성(Composition)의 핵심 개념

> **“상속보다 구성을 사용하라.” (Favor Composition over Inheritance)**

**구성(Composition)** 이란  
객체가 또 다른 객체를 **멤버 변수로 보유(has-a)** 하여 행동을 **위임(delegate)** 하는 방식이다.  
즉, “Duck은 FlyBehavior를 **가지고(has-a)** 있다.”

### 🧠 구성의 장점

- **유연성:** 런타임 시점에 객체 교체 가능 → 동적 행동 변경  
- **캡슐화:** 변하는 행동을 별도 클래스로 분리 → 수정이 다른 코드에 영향 없음  
- **OCP 충족:** 기존 코드 수정 없이 새로운 행동 추가 가능  
- **테스트 용이성:** 각 행동을 독립적으로 테스트 가능  

### ⚙️ 상속과 구성의 차이

| 비교 항목 | 상속(Inheritance) | 구성(Composition) |
|------------|--------------------|--------------------|
| 관계 | `A는 B이다 (is-a)` | `A는 B를 가진다 (has-a)` |
| 변경 대응 | 부모 변경 시 자식 영향 | 독립적 변경 가능 |
| 런타임 교체 | 불가능 | 가능 (`setBehavior()` 등으로 교체 가능) |
| 확장성 | 계층 구조 깊어짐 | 조합으로 다양한 변형 가능 |

> 🧩 결론:  
> 상속은 “고정적 구조”에 적합하고,  
> 구성은 “변화에 유연한 구조”에 적합하다.

---

## 🧩 4️⃣ 인터페이스에 맞춰 프로그래밍하라

> **Program to an interface, not an implementation.**

- 변하는 부분은 **인터페이스 기반으로 프로그래밍**  
- **상위 형식(= 추상화된 형태: 인터페이스, 추상 클래스)** 에 의존  
- 구체 클래스를 직접 다루지 않음  
- 상위형식으로 선언하면 **다양한 하위 구현체를 런타임에 교체 가능**  
- 결과적으로 **확장성·재사용성 증가**, 결합도 감소  

---

## 💻 예시 코드 (오리 예제)

```java
// 전략 인터페이스
public interface FlyBehavior {
    void fly();
}

public class FlyWithWings implements FlyBehavior {
    public void fly() {
        System.out.println("날개로 난다!");
    }
}

public class FlyNoWay implements FlyBehavior {
    public void fly() {
        System.out.println("못 난다!");
    }
}

// Context 클래스
public class Duck {
    private FlyBehavior flyBehavior;

    public void performFly() {
        flyBehavior.fly();
    }

    public void setFlyBehavior(FlyBehavior fb) {
        this.flyBehavior = fb;
    }
}
````

```java
// 실행 예시
public class Main {
    public static void main(String[] args) {
        Duck mallard = new Duck();
        mallard.setFlyBehavior(new FlyWithWings()); // 동적 교체 가능
        mallard.performFly(); // "날개로 난다!"
    }
}
```

> 🧠 핵심: **행동을 상속하지 말고, 구성하라!**

---

## 🧠 5️⃣ 인스턴스 변수 혼동 해소

| 구분                    | 설명                      | 비고                  |
| --------------------- | ----------------------- | ------------------- |
| **멤버 변수**             | 클래스 내부, 메서드 외부의 변수      | 클래스 변수 + 인스턴스 변수 포함 |
| **클래스 변수 (`static`)** | 모든 인스턴스가 공유             | 클래스명으로 접근           |
| **인스턴스 변수**           | 객체 생성 시 각 인스턴스마다 별도로 존재 | `new` 시 메모리 할당      |
| **지역 변수**             | 메서드 내부에 선언된 변수          | 스택(Stack) 영역에 저장    |

> 💡 `new Duck()` 은 **인스턴스 생성**
> “인스턴스 변수”는 **객체 내부의 상태(속성)** 을 의미함.

---

## 🧭 철학적 메시지

> **"프로그램에서 진리는 변화다."**
> 완벽한 구조도 시간이 지나면 변화해야 한다.
> 따라서 **변화를 수용할 수 있는 구조**를 만드는 것이 객체지향 설계의 핵심이다.

---

## 📘 디자인 패턴을 왜 배워야 하는가

> “패턴을 배운다는 건 단순히 외우는 게 아니라, **생각하는 방법을 배우는 것**이다.”

### 🎯 1️⃣ 복잡한 문제를 단순하게 푸는 방법을 배운다

* 실무의 문제는 교과서 예제처럼 단순하지 않다.
* 디자인 패턴은 **검증된 문제 해결 방식(Problem–Solution Template)** 이다.
* 즉, “이 상황엔 이렇게 설계하면 된다”는 **지식의 재활용 도구**다.

### 🧩 2️⃣ 팀 내 커뮤니케이션 언어가 된다

* “전략 패턴으로 캡슐화하자”, “팩토리로 객체 생성을 위임하자”
  → 한 문장으로 설계 의도를 공유 가능
* 즉, **코드보다 빠르고 명확한 설계 의사소통 수단**이 된다.

### 🧠 3️⃣ 아키텍처 사고력을 키운다

* 코드를 기능 단위로만 보지 않고, **구조 단위로 사고**하게 된다.
* “이 부분은 나중에 변할 수 있으니 인터페이스로 분리하자.”
  → 이런 사고 자체가 **디자인 패턴적 사고**다.

### ⚙️ 4️⃣ 프레임워크·라이브러리를 더 깊이 이해하게 된다

* Spring, JPA, MyBatis, Kafka 등은 모두 **디자인 패턴의 집합체**이다.
* 내부 동작 원리를 이해하면, 단순 사용자에서 **설계자 수준**으로 성장한다.

### 💬 5️⃣ 후배에게 “좋은 코드란 무엇인가”를 설명할 수 있다

* 단순히 “이건 맞고 틀리다”가 아니라
  → “이건 전략 패턴 구조라서 나중에 유지보수가 쉽다.”
  처럼 **근거 기반의 피드백**을 줄 수 있다.

---

## 📝 학습 메모

* ✅ 상속 → 인터페이스 → 구성으로 진화하는 흐름 이해 완료
* ✅ 상위형식 = 추상화된 형태 (인터페이스, 추상 클래스)
* ✅ 전략 패턴 구조를 코드로 직접 구현 예정
* ✅ 디자인 패턴의 필요성과 실무적 가치까지 명확히 이해 완료

---

> 🧩 *“상속보다 조합(위임), 기능보다 구조, 코드보다 사고력.”*
> 오늘의 키워드: **전략(Strategy)**
> *Written by 7AAB*

---
