---
# 🎯 Design Pattern 01 – 전략 패턴 (Strategy Pattern)
---

## 📘 개요

**전략 패턴(Strategy Pattern)** 은 *알고리즘군*을 정의하고 각 알고리즘을 캡슐화하여 **상호 교체 가능**하게 만들며, 알고리즘을 **그것을 사용하는 클라이언트로부터 독립적으로** 변화시킬 수 있게 한다.

> 💬 프로그램에서 진리는 **변화**다.
> 변화에 유연하게 대응하기 위해 **상속보다 구성(Composition)** 을 사용한다.

---

## 🧩 1️⃣ 상속의 한계

* 재사용성은 좋지만 **유연성 부족**
* 부모 클래스 변경 시 **모든 자식 클래스 영향**
* **코드 중복** 및 **불필요한 상속**
* **변화가 잦은 영역**에는 부적합 → 유지보수 어려움

> “상속은 코드를 공유하지만, 변화에는 닫혀 있다.”

---

## 🧩 2️⃣ 인터페이스(구현)의 한계

* 새로운 기능 추가 시 **모든 클래스에 구현 필요**
* 인터페이스 변경 시 **모든 구현 클래스 수정 필요**
* **코드 중복**, **재사용 어려움**

> “인터페이스는 유연하지만, 구현의 반복을 초래한다.”

---

## 🧩 3️⃣ 문제 해결 방향

* **변하지 않는 것**과 **변하는 것**을 분리한다.
* 변하는 부분은 **별도의 클래스로 묶어 캡슐화(Encapsulation)** 한다.
* 즉, **“구성을 통해 행동을 바꾼다.”**

> 👉 변화하는 코드를 따로 분리하면, 새로운 행동 추가 시 기존 클래스 수정이 필요 없다.
> (OCP – 개방-폐쇄 원칙 충족)

---

## 🧩 4️⃣ 인터페이스에 맞춰 프로그래밍하라

> **Program to an interface, not an implementation.**

* 변하는 부분은 **인터페이스 기반으로 프로그래밍**
* **상위 형식(= 추상화된 형태: 인터페이스, 추상 클래스)** 에 의존
* 구체 클래스를 직접 다루지 않음
* 상위형식으로 선언하면 **다양한 하위 구현체를 런타임에 교체 가능**
* 결과적으로 **확장성·재사용성 증가**, 결합도 감소

---

## 💻 예시 코드 (오리 예제)

```java
// 전략 인터페이스
public interface FlyBehavior {
    void fly();
}

public class FlyWithWings implements FlyBehavior {
    public void fly() {
        System.out.println("날개로 난다!");
    }
}

public class FlyNoWay implements FlyBehavior {
    public void fly() {
        System.out.println("못 난다!");
    }
}

// Context 클래스
public class Duck {
    private FlyBehavior flyBehavior;

    public void performFly() {
        flyBehavior.fly();
    }

    public void setFlyBehavior(FlyBehavior fb) {
        this.flyBehavior = fb;
    }
}
```

```java
// 실행 예시
public class Main {
    public static void main(String[] args) {
        Duck mallard = new Duck();
        mallard.setFlyBehavior(new FlyWithWings()); // 동적 교체 가능
        mallard.performFly(); // "날개로 난다!"
    }
}
```

> 🧠 핵심: **행동을 상속하지 말고, 구성하라!**

---

## 🧠 5️⃣ 인스턴스 변수 혼동 해소

| 구분                    | 설명                      | 비고                  |
| --------------------- | ----------------------- | ------------------- |
| **멤버 변수**             | 클래스 내부, 메서드 외부의 변수      | 클래스 변수 + 인스턴스 변수 포함 |
| **클래스 변수 (`static`)** | 모든 인스턴스가 공유             | 클래스명으로 접근           |
| **인스턴스 변수**           | 객체 생성 시 각 인스턴스마다 별도로 존재 | `new` 시 메모리 할당      |
| **지역 변수**             | 메서드 내부에 선언된 변수          | 스택(Stack) 영역에 저장    |

> 💡 `new Duck()` 은 **인스턴스 생성**
> “인스턴스 변수”는 **객체 내부의 상태(속성)** 을 의미함.

---

## 🧭 철학적 메시지

> **"프로그램에서 진리는 변화다."**
> 완벽한 구조도 시간이 지나면 변화해야 한다.
> 따라서 **변화를 수용할 수 있는 구조**를 만드는 것이 객체지향 설계의 핵심이다.

---

## 📝 학습 메모

* ✅ 상속 → 인터페이스 → 구성으로 진화하는 흐름 이해 완료
* ✅ 상위형식 = 추상화된 형태 (인터페이스, 추상 클래스)
* ✅ 전략 패턴 구조를 코드로 직접 구현 예정

---
